<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF → Image & Image Tools — Single File</title>

  <!-- Tailwind Play CDN for quick Tailwind usage -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- PDF.js (render PDFs in-browser) -->
  <script src="https://unpkg.com/pdfjs-dist@3.9.179/build/pdf.min.js"></script>
  <script>
    // point worker to CDN
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.9.179/build/pdf.worker.min.js';
  </script>

  <!-- JSZip for zipping images to download -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>
  <!-- FileSaver for saving ZIP -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <style>
    /* Tiny custom styles for crop selection */
    .crop-canvas { touch-action: none; }
    .thumb { image-rendering: -webkit-optimize-contrast; }
    /* subtle 3D header gradient */
    .brand-grad { background: linear-gradient(90deg,#4f46e5,#06b6d4); }
  </style>
</head>
<body class="bg-slate-50 min-h-screen text-slate-800">

  <header class="brand-grad text-white p-4 sticky top-0 z-20 shadow">
    <div class="container mx-auto flex items-center justify-between gap-4">
      <div class="flex items-center gap-3">
        <svg class="w-9 h-9 bg-white/10 rounded p-1" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 7v10a2 2 0 0 0 2 2h14" stroke-width="1.5"></path><path d="M7 3h10v4H7z" stroke-width="1.5"></path></svg>
        <div>
          <div class="font-semibold text-lg">ToolFace — PDF & Image Tools</div>
          <div class="text-xs opacity-80">PDF → Image, Image Convert, Resize, Crop & Enhance — all in-browser</div>
        </div>
      </div>

      <nav class="hidden sm:flex items-center gap-4 text-sm">
        <a href="#pdftools" class="hover:underline">PDF Tools</a>
        <a href="#imagetools" class="hover:underline">Image Tools</a>
        <a href="#about" class="hover:underline">About</a>
      </nav>
    </div>
  </header>

  <main class="container mx-auto p-6">
    <section id="pdftools" class="grid lg:grid-cols-3 gap-6">
      <!-- Left column: Upload -->
      <div class="lg:col-span-1 bg-white rounded-lg p-5 shadow">
        <h2 class="text-xl font-semibold mb-2">PDF → Image</h2>
        <p class="text-sm text-slate-600 mb-4">Upload a PDF and convert pages to images (PNG / JPG / WebP). Convert single pages or all pages into a zip.</p>

        <label class="block">
          <span class="text-sm font-medium">Upload PDF</span>
          <input id="pdf-file" type="file" accept="application/pdf" class="mt-2 block w-full text-sm" />
        </label>

        <div class="mt-4 space-y-2">
          <label class="block text-sm">
            <span>Image format</span>
            <select id="pdf-output-format" class="mt-1 w-full rounded border px-3 py-2 text-sm">
              <option value="png">PNG</option>
              <option value="jpeg">JPEG</option>
              <option value="webp">WEBP</option>
            </select>
          </label>

          <label class="block text-sm">
            <span>Scale (page rendering quality)</span>
            <input id="pdf-scale" type="range" min="0.5" max="3" step="0.1" value="1.5" />
            <div class="text-xs text-slate-500 mt-1">Higher = larger image (slow).</div>
          </label>

          <div class="flex gap-2 mt-2">
            <button id="pdf-render-all" class="flex-1 px-3 py-2 bg-indigo-600 text-white rounded">Render Pages</button>
            <button id="pdf-zip-all" class="flex-1 px-3 py-2 border rounded">Download All (ZIP)</button>
          </div>

          <div id="pdf-meta" class="text-xs text-slate-600 mt-2"></div>
        </div>
      </div>

      <!-- Middle column: Thumbnails / pages -->
      <div class="lg:col-span-1 bg-white rounded-lg p-5 shadow overflow-hidden">
        <h3 class="font-semibold mb-3">Pages</h3>
        <div id="thumbnails" class="grid grid-cols-2 md:grid-cols-3 gap-3 max-h-[64vh] overflow-auto p-1">
          <!-- thumbnails go here -->
        </div>
      </div>

      <!-- Right column: Preview & actions -->
      <div class="lg:col-span-1 bg-white rounded-lg p-5 shadow flex flex-col">
        <h3 class="font-semibold mb-3">Preview</h3>
        <div class="flex-1 border rounded p-2 bg-slate-50 flex items-center justify-center">
          <div id="page-preview-empty" class="text-center text-sm text-slate-400">
            No page selected — render PDF pages to see previews here.
          </div>
          <canvas id="page-preview" class="hidden max-w-full h-auto"></canvas>
        </div>

        <div id="page-actions" class="mt-4 hidden">
          <div class="flex gap-2">
            <button id="download-page" class="flex-1 px-3 py-2 bg-emerald-600 text-white rounded">Download Page</button>
            <button id="open-new-tab" class="flex-1 px-3 py-2 border rounded">Open New Tab</button>
          </div>

          <div class="mt-3 text-sm text-slate-600">
            Page <span id="current-page-num"></span> of <span id="total-pages"></span>
          </div>
        </div>
      </div>
    </section>

    <!-- Image Tools Section -->
    <section id="imagetools" class="mt-8 grid md:grid-cols-2 gap-6">
      <div class="bg-white rounded-lg p-5 shadow">
        <h2 class="text-lg font-semibold mb-2">Image Tools</h2>
        <p class="text-sm text-slate-600 mb-4">Upload an image to convert format, resize, crop, or apply basic enhancement.</p>

        <label class="block mb-2">
          <span class="text-sm">Upload Image</span>
          <input id="img-file" type="file" accept="image/*" class="mt-2 block w-full text-sm" />
        </label>

        <div class="grid grid-cols-2 gap-3">
          <div>
            <label class="block text-sm">Convert to</label>
            <select id="img-format" class="mt-1 w-full rounded border px-3 py-2 text-sm">
              <option value="png">PNG</option>
              <option value="jpeg">JPEG</option>
              <option value="webp">WEBP</option>
            </select>
          </div>

          <div>
            <label class="block text-sm">Quality (JPEG/WebP)</label>
            <input id="img-quality" type="range" min="30" max="100" step="5" value="90" />
          </div>
        </div>

        <div class="mt-3 grid grid-cols-2 gap-2">
          <button id="convert-image" class="px-3 py-2 bg-indigo-600 text-white rounded">Convert & Download</button>
          <button id="open-image-tab" class="px-3 py-2 border rounded">Open in Tab</button>
        </div>

        <hr class="my-4"/>

        <h3 class="font-semibold">Resize</h3>
        <div class="grid grid-cols-2 gap-3 mt-2">
          <label class="text-sm">
            Width (px)
            <input id="resize-width" type="number" class="mt-1 w-full rounded border px-2 py-1" placeholder="auto" />
          </label>
          <label class="text-sm">
            Height (px)
            <input id="resize-height" type="number" class="mt-1 w-full rounded border px-2 py-1" placeholder="auto" />
          </label>
        </div>
        <div class="flex gap-2 mt-3">
          <button id="resize-apply" class="flex-1 px-3 py-2 bg-emerald-600 text-white rounded">Apply Resize</button>
          <button id="reset-image" class="flex-1 px-3 py-2 border rounded">Reset</button>
        </div>

        <hr class="my-4"/>

        <h3 class="font-semibold">Enhance (Brightness / Contrast)</h3>
        <div class="grid grid-cols-1 gap-2 mt-2">
          <label class="text-xs">Brightness <span id="brightness-val" class="font-medium">100%</span></label>
          <input id="brightness" type="range" min="50" max="150" value="100" />
          <label class="text-xs">Contrast <span id="contrast-val" class="font-medium">100%</span></label>
          <input id="contrast" type="range" min="50" max="150" value="100" />
          <button id="apply-enhance" class="mt-2 px-3 py-2 bg-indigo-600 text-white rounded">Apply Enhance</button>
        </div>
      </div>

      <!-- Right side: crop & preview -->
      <div class="bg-white rounded-lg p-5 shadow">
        <h3 class="font-semibold mb-3">Crop & Preview</h3>
        <div class="border rounded p-3 bg-slate-50">
          <div class="relative">
            <canvas id="img-canvas" class="crop-canvas w-full max-h-[60vh]"></canvas>
            <!-- selection overlay will be painted on canvas -->
          </div>
        </div>

        <div class="mt-3 flex gap-2">
          <button id="start-crop" class="flex-1 px-3 py-2 border rounded">Start Crop</button>
          <button id="apply-crop" class="flex-1 px-3 py-2 bg-emerald-600 text-white rounded">Apply Crop</button>
        </div>

        <div class="mt-3 text-sm text-slate-600">Tip: Drag on the image to draw selection. Use Resize tool first for simpler aspect.</div>

        <div class="mt-4">
          <h4 class="font-semibold">Result</h4>
          <div id="result-area" class="mt-2"></div>
        </div>

      </div>
    </section>

    <section id="about" class="mt-8">
      <div class="bg-white rounded-lg p-5 shadow">
        <h3 class="font-semibold">About</h3>
        <p class="text-sm text-slate-600 mt-2">This single-file demo performs client-side PDF rendering (page → canvas) and image manipulations entirely in the browser — no files are sent to a server. It uses <strong>pdf.js</strong> to render PDF pages, <strong>canvas</strong> for image operations, <strong>JSZip</strong> to create zip archives, and <strong>FileSaver</strong> to initiate downloads.</p>
      </div>
    </section>
  </main>

  <footer class="text-center text-xs text-slate-500 py-6">
    Built with ❤️ — In-browser. Files never leave your machine.
  </footer>

<script>
/* ==================================================================================
   Utility helpers
   ================================================================================== */

function bytesToSize(bytes) {
  if (!bytes) return '0 B';
  const sizes = ['B','KB','MB','GB','TB'];
  const i = Math.floor(Math.log(bytes)/Math.log(1024));
  return (bytes/Math.pow(1024,i)).toFixed(2)+' '+sizes[i];
}

/* ==================================================================================
   PDF → Image logic (pdf.js)
   ================================================================================== */

let pdfDoc = null;
let pageCanvases = []; // store canvas blobs -> for zip
const thumbnails = document.getElementById('thumbnails');
const previewCanvas = document.getElementById('page-preview');
const previewEmpty = document.getElementById('page-preview-empty');
const pageActions = document.getElementById('page-actions');
const currentPageNum = document.getElementById('current-page-num');
const totalPagesEl = document.getElementById('total-pages');

document.getElementById('pdf-file').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  // clear
  thumbnails.innerHTML = '';
  pageCanvases = [];
  previewCanvas.classList.add('hidden');
  previewEmpty.style.display = 'block';
  pageActions.classList.add('hidden');
  pdfDoc = null;

  const arrayBuffer = await file.arrayBuffer();
  const loadingTask = pdfjsLib.getDocument({data:arrayBuffer});
  document.getElementById('pdf-meta').textContent = 'Loading PDF...';
  try {
    pdfDoc = await loadingTask.promise;
    document.getElementById('pdf-meta').textContent = `Loaded: ${file.name} — ${pdfDoc.numPages} pages, ${bytesToSize(file.size)}`;
    totalPagesEl.textContent = pdfDoc.numPages;
    // create thumbnail placeholders
    for (let p=1;p<=pdfDoc.numPages;p++){
      const box = document.createElement('div');
      box.className = 'p-1 bg-white border rounded flex flex-col items-center justify-center';
      box.innerHTML = `<div class="text-xs text-slate-500 mb-1">Page ${p}</div><div class="w-full aspect-[3/4] bg-slate-100 flex items-center justify-center"><div class="text-xs text-slate-400">Not rendered</div></div>`;
      thumbnails.appendChild(box);
    }
  } catch(err){
    document.getElementById('pdf-meta').textContent = 'Failed to load PDF.';
    console.error(err);
  }
});

async function renderPageToCanvas(pageNumber, scale=1.5){
  if (!pdfDoc) throw new Error('No PDF loaded');
  const page = await pdfDoc.getPage(pageNumber);
  const viewport = page.getViewport({ scale });
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d', {alpha: false});
  canvas.width = Math.floor(viewport.width);
  canvas.height = Math.floor(viewport.height);

  const renderContext = {
    canvasContext: context,
    viewport
  };
  await page.render(renderContext).promise;
  return canvas;
}

async function renderAllPages() {
  if (!pdfDoc) return alert('Please upload a PDF first.');
  const scale = parseFloat(document.getElementById('pdf-scale').value || 1.5);
  thumbnails.innerHTML = '';
  pageCanvases = [];
  for (let p=1;p<=pdfDoc.numPages;p++){
    const thumbBox = document.createElement('div');
    thumbBox.className = 'p-1 bg-white border rounded flex flex-col items-center';
    thumbnails.appendChild(thumbBox);

    // small progressive render for thumbnail
    const canvas = await renderPageToCanvas(p, scale);
    // create scaled thumbnail image
    const thumb = document.createElement('img');
    thumb.className = 'thumb rounded shadow-sm cursor-pointer';
    thumb.style.maxWidth = '100%';
    thumb.style.height = '120px';
    thumb.src = canvas.toDataURL('image/png');
    thumb.title = `Page ${p}`;
    thumbBox.appendChild(thumb);
    const meta = document.createElement('div');
    meta.className = 'text-xs text-slate-500 mt-1';
    meta.textContent = `Page ${p}`;
    thumbBox.appendChild(meta);

    // store original canvas for full-quality download (we can export to PNG/JPEG/WebP)
    pageCanvases[p-1] = canvas;

    thumb.addEventListener('click', () => {
      showPreview(p-1);
    });
  }
  document.getElementById('pdf-meta').textContent = `Rendered ${pdfDoc.numPages} pages. Click a thumbnail to preview/download.`;
}

async function showPreview(index) {
  const canvas = pageCanvases[index];
  if (!canvas) return;
  // show on preview canvas scaled to available width
  const ctx = previewCanvas.getContext('2d');
  // size the preview canvas to fit container width
  const maxWidth = Math.min(previewCanvas.parentElement.clientWidth - 20, canvas.width);
  const ratio = maxWidth / canvas.width;
  previewCanvas.width = Math.floor(canvas.width * ratio);
  previewCanvas.height = Math.floor(canvas.height * ratio);
  ctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
  ctx.drawImage(canvas, 0, 0, previewCanvas.width, previewCanvas.height);
  previewCanvas.classList.remove('hidden');
  previewEmpty.style.display = 'none';
  pageActions.classList.remove('hidden');
  currentPageNum.textContent = index + 1;
  document.getElementById('download-page').onclick = () => downloadCanvasAsImage(canvas, document.getElementById('pdf-output-format').value, true);
  document.getElementById('open-new-tab').onclick = () => {
    const dataUrl = canvas.toDataURL('image/png');
    window.open(dataUrl,'_blank');
  };
}

/* Download a canvas as selected format */
function downloadCanvasAsImage(canvas, format='png', useBlobName=false){
  format = format === 'jpg' ? 'jpeg' : format;
  const mime = format === 'png' ? 'image/png' : (format === 'webp' ? 'image/webp' : 'image/jpeg');
  // get blob and trigger download
  canvas.toBlob((blob)=>{
    const ext = format === 'jpeg' ? 'jpg' : format;
    const fileName = useBlobName ? `page-${Date.now()}.${ext}` : `image.${ext}`;
    saveAs(blob, fileName); // FileSaver
  }, mime, document.getElementById('pdf-output-format').value === 'jpeg' ? (document.getElementById('pdf-quality') ? parseFloat(document.getElementById('pdf-quality').value)/100 : undefined) : undefined);
}

/* Zip all pages as selected format */
async function zipAllPages(){
  if (!pageCanvases.length) {
    alert('No rendered pages. Click "Render Pages" first.');
    return;
  }
  const zip = new JSZip();
  const format = document.getElementById('pdf-output-format').value;
  const mime = format === 'png' ? 'image/png' : (format === 'webp' ? 'image/webp' : 'image/jpeg');

  // use a progress overlay
  const ZIPNAME = `pdf-pages-${Date.now()}.zip`;
  document.getElementById('pdf-meta').textContent = 'Zipping images...';

  for (let i=0;i<pageCanvases.length;i++){
    const canvas = pageCanvases[i];
    const blob = await new Promise(res => canvas.toBlob(res, mime, 0.95));
    zip.file(`page-${i+1}.${format === 'jpeg' ? 'jpg' : format}`, blob);
  }

  const content = await zip.generateAsync({type:'blob'});
  saveAs(content, ZIPNAME);
  document.getElementById('pdf-meta').textContent = `Downloaded ZIP (${pageCanvases.length} images).`;
}

/* bind events */
document.getElementById('pdf-render-all').addEventListener('click', renderAllPages);
document.getElementById('pdf-zip-all').addEventListener('click', zipAllPages);

/* ==================================================================================
   Image Tools (canvas-based)
   ================================================================================== */

let originalImage = null; // HTMLImageElement
let workingCanvas = document.getElementById('img-canvas');
let workingCtx = workingCanvas.getContext('2d');
let currentImageBlobURL = null;
let cropState = { active:false, start:null, end:null, dragging:false };

const imgFileInput = document.getElementById('img-file');
imgFileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  if (currentImageBlobURL) URL.revokeObjectURL(currentImageBlobURL);
  currentImageBlobURL = URL.createObjectURL(file);
  const img = new Image();
  img.onload = () => {
    originalImage = img;
    fitCanvasToImage();
    drawImageToCanvas();
    document.getElementById('result-area').innerHTML = '';
  }
  img.src = currentImageBlobURL;
});

function fitCanvasToImage() {
  if (!originalImage) return;
  const maxW = workingCanvas.parentElement.clientWidth - 20;
  const maxH = window.innerHeight * 0.55;
  let w = originalImage.width;
  let h = originalImage.height;
  const ratio = Math.min(maxW / w, maxH / h, 1);
  workingCanvas.width = Math.floor(w * ratio);
  workingCanvas.height = Math.floor(h * ratio);
}

function drawImageToCanvas(applyFilter=false) {
  if (!originalImage) return;
  // draw image to canvas with current enhance filters applied
  workingCtx.clearRect(0,0,workingCanvas.width, workingCanvas.height);
  // compute scaled size to fit canvas
  const scaleX = workingCanvas.width / originalImage.width;
  const scaleY = workingCanvas.height / originalImage.height;
  workingCtx.drawImage(originalImage, 0, 0, originalImage.width, originalImage.height, 0, 0, workingCanvas.width, workingCanvas.height);
}

function getCanvasDataURL(mime='image/png', quality=0.9){
  return workingCanvas.toDataURL(mime, quality);
}

document.getElementById('convert-image').addEventListener('click', async () => {
  if (!originalImage) return alert('Upload an image first.');
  const format = document.getElementById('img-format').value;
  const quality = parseInt(document.getElementById('img-quality').value || 90) / 100;
  const mime = format === 'png' ? 'image/png' : (format === 'webp' ? 'image/webp' : 'image/jpeg');

  workingCanvas.toBlob((blob)=>{
    const ext = format === 'jpeg' ? 'jpg' : format;
    saveAs(blob, `image-${Date.now()}.${ext}`);
  }, mime, quality);
});

document.getElementById('open-image-tab').addEventListener('click', () => {
  if (!originalImage) return;
  const data = getCanvasDataURL();
  window.open(data, '_blank');
});

/* Resize handlers */
document.getElementById('resize-apply').addEventListener('click', () => {
  if (!originalImage) return alert('Upload an image first.');
  const w = parseInt(document.getElementById('resize-width').value);
  const h = parseInt(document.getElementById('resize-height').value);
  // compute target size: if only one provided, preserve aspect
  let targetW = originalImage.width, targetH = originalImage.height;
  if (w && h) { targetW = w; targetH = h; }
  else if (w) { targetW = w; targetH = Math.round((originalImage.height / originalImage.width) * w); }
  else if (h) { targetH = h; targetW = Math.round((originalImage.width / originalImage.height) * h); }
  else return alert('Enter width and/or height.');

  // create an offscreen canvas to draw at target resolution, then set as new originalImage
  const off = document.createElement('canvas');
  off.width = targetW;
  off.height = targetH;
  const offCtx = off.getContext('2d');
  offCtx.drawImage(originalImage, 0, 0, off.width, off.height);
  off.toBlob((blob)=>{
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      originalImage = img;
      fitCanvasToImage();
      drawImageToCanvas();
      document.getElementById('result-area').innerHTML = '<div class="text-sm text-slate-600">Resize applied.</div>';
    };
    img.src = url;
  }, 'image/png');
});

document.getElementById('reset-image').addEventListener('click', () => {
  if (!currentImageBlobURL) return;
  const img = new Image();
  img.onload = () => { originalImage = img; fitCanvasToImage(); drawImageToCanvas(); document.getElementById('result-area').innerHTML=''; };
  img.src = currentImageBlobURL;
});

/* Enhance sliders */
const brightnessEl = document.getElementById('brightness');
const contrastEl = document.getElementById('contrast');
brightnessEl.addEventListener('input', ()=> document.getElementById('brightness-val').textContent = brightnessEl.value + '%');
contrastEl.addEventListener('input', ()=> document.getElementById('contrast-val').textContent = contrastEl.value + '%');

document.getElementById('apply-enhance').addEventListener('click', () => {
  if (!originalImage) return alert('Upload an image first.');
  // apply CSS filter-like rendering on canvas using an offscreen canvas
  const b = parseInt(brightnessEl.value) / 100;
  const c = parseInt(contrastEl.value) / 100;
  const off = document.createElement('canvas');
  off.width = originalImage.width;
  off.height = originalImage.height;
  const offCtx = off.getContext('2d');
  offCtx.drawImage(originalImage, 0, 0);
  try {
    // get image data and manipulate brightness/contrast
    const imgData = offCtx.getImageData(0,0,off.width,off.height);
    const data = imgData.data;
    // simple formula: new = (old - 128)*contrast + 128*brightness
    const contrastFactor = (259 * (c*255 + 255)) / (255 * (259 - c*255)); // approximate
    for (let i=0;i<data.length;i+=4){
      for (let ch=0;ch<3;ch++){
        let val = data[i+ch];
        // apply brightness multiplier then contrast around 128
        val = (val - 128) * (c) + 128; // contrast
        val = val * b; // brightness
        data[i+ch] = Math.max(0, Math.min(255, val));
      }
    }
    offCtx.putImageData(imgData, 0, 0);
    off.toBlob((blob)=>{
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => { originalImage = img; fitCanvasToImage(); drawImageToCanvas(); document.getElementById('result-area').innerHTML = '<div class="text-sm text-slate-600">Enhance applied.</div>'; };
      img.src = url;
    }, 'image/png');
  } catch(err) {
    // if large images produce issues, fallback to using CSS filters drawn onto a temporary canvas
    console.warn('Pixel manipulation failed, using fallback filter draw', err);
    const temp = document.createElement('canvas');
    temp.width = originalImage.width;
    temp.height = originalImage.height;
    const tctx = temp.getContext('2d');
    tctx.filter = `brightness(${brightnessEl.value}%) contrast(${contrastEl.value}%)`;
    tctx.drawImage(originalImage, 0, 0);
    temp.toBlob((blob)=>{
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => { originalImage = img; fitCanvasToImage(); drawImageToCanvas(); document.getElementById('result-area').innerHTML = '<div class="text-sm text-slate-600">Enhance applied (fallback).</div>'; };
      img.src = url;
    }, 'image/png');
  }
});

/* ---------------------------------------------------
   Crop interactions (simple selection rectangle on canvas)
   --------------------------------------------------- */

let isSelecting = false;
let selStart = null;
let selEnd = null;

workingCanvas.addEventListener('pointerdown', (e) => {
  if (!originalImage) return;
  if (!document.getElementById('start-crop').classList.contains('active')) return;
  workingCanvas.setPointerCapture(e.pointerId);
  isSelecting = true;
  const rect = workingCanvas.getBoundingClientRect();
  selStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  selEnd = { ...selStart };
  drawSelection();
});

workingCanvas.addEventListener('pointermove', (e) => {
  if (!isSelecting) return;
  const rect = workingCanvas.getBoundingClientRect();
  selEnd = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  drawSelection();
});

workingCanvas.addEventListener('pointerup', (e) => {
  if (!isSelecting) return;
  workingCanvas.releasePointerCapture(e.pointerId);
  isSelecting = false;
  drawSelection();
});

function drawSelection(){
  // redraw base image then selection overlay
  drawImageToCanvas();
  if (!selStart || !selEnd) return;
  const x = Math.min(selStart.x, selEnd.x);
  const y = Math.min(selStart.y, selEnd.y);
  const w = Math.abs(selEnd.x - selStart.x);
  const h = Math.abs(selEnd.y - selStart.y);
  // overlay dim
  workingCtx.fillStyle = 'rgba(0,0,0,0.35)';
  workingCtx.fillRect(0,0,workingCanvas.width,workingCanvas.height);
  // clear selected rect area
  workingCtx.clearRect(x,y,w,h);
  // border
  workingCtx.strokeStyle = '#fff';
  workingCtx.lineWidth = 2;
  workingCtx.strokeRect(x + 0.5, y + 0.5, w, h);
}

document.getElementById('start-crop').addEventListener('click', () => {
  const el = document.getElementById('start-crop');
  el.classList.toggle('active');
  el.classList.toggle('bg-slate-200');
  el.classList.toggle('border');
  if (!originalImage) alert('Upload image first.');
  else {
    if (el.classList.contains('active')) {
      el.textContent = 'Cropping (drag on image)';
    } else {
      el.textContent = 'Start Crop';
      selStart = selEnd = null;
      drawImageToCanvas();
    }
  }
});

document.getElementById('apply-crop').addEventListener('click', () => {
  if (!selStart || !selEnd) return alert('Draw selection on the image first.');
  // compute selection in original image coordinates
  const sx = Math.min(selStart.x, selEnd.x) / workingCanvas.width * originalImage.width;
  const sy = Math.min(selStart.y, selEnd.y) / workingCanvas.height * originalImage.height;
  const sw = Math.abs(selEnd.x - selStart.x) / workingCanvas.width * originalImage.width;
  const sh = Math.abs(selEnd.y - selStart.y) / workingCanvas.height * originalImage.height;
  if (sw < 5 || sh < 5) return alert('Selection too small.');
  const off = document.createElement('canvas');
  off.width = Math.floor(sw);
  off.height = Math.floor(sh);
  const offCtx = off.getContext('2d');
  offCtx.drawImage(originalImage, sx, sy, sw, sh, 0, 0, off.width, off.height);
  off.toBlob((blob)=>{
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      originalImage = img;
      fitCanvasToImage();
      drawImageToCanvas();
      document.getElementById('result-area').innerHTML = `<a class="text-sm text-indigo-600 hover:underline" href="${url}" target="_blank">Open cropped image</a>`;
      // reset selection
      selStart = selEnd = null;
      document.getElementById('start-crop').classList.remove('active');
      document.getElementById('start-crop').textContent = 'Start Crop';
      drawImageToCanvas();
    };
    img.src = url;
  }, 'image/png');
});

/* ==================================================================================
   Small UX improvements
   ================================================================================== */

window.addEventListener('resize', () => {
  if (originalImage) { fitCanvasToImage(); drawImageToCanvas(); }
  if (pageCanvases.length && previewCanvas && !previewCanvas.classList.contains('hidden')) {
    // re-render preview scale
    const idx = parseInt(currentPageNum.textContent) - 1;
    if (!isNaN(idx) && pageCanvases[idx]) showPreview(idx);
  }
});

</script>

</body>
</html>
